//------------------------------------------------------------------
// EasyLanguage Code for Tradestation / MultiCharts of Strategy 3.2.146
//
//   Generated by StrategyQuant X Build 139
//   at 07/01/2024 02:34
//  
//   Backtested on @YM_TS / M240, 2009.01.02 - 2024.06.26 
//
//   Generated for Main chart = Current Symbol / Current TF;
//------------------------------------------------------------------

inputs:
	// Strategy variables
	MagicNumber(11111),
	MACDMainFast1(255),
	MACDMainSlow1(379),
	MACDMainSmooth1(9),
	LinRegBarOpnAftOpnPrd1(14),
	PriceEntryMult1(1.8),
	BarsValid1(17),
	ReplaceExisting1(true),
	ExitAfterBars1(85),
	MoveSL2BE1(210),
	SL2BEAddPipsCoef1(4.4),
	ProfitTarget1(8),
	StopLoss1(4),
	TrailingStop1(50),
	TrailingActivation1(110),
	BBRangePeriod1(20),

	// Trading Options
    
	DontTradeOnWeekends(true),
	FridayCloseTime(0038),
	SundayOpenTime(0038),	
	ExitAtEndOfDay(true),
	DayExitTime(1500),    
	ExitOnFriday(true),
	FridayExitTime(1430),
	LimitSignalsTimeRange(true),
	SignalTimeRangeFrom(0800),
	SignalTimeRangeTo(1600),
	ExitAtEndOfRange(true),
	OrderTypeToExit(0),
	LimitMaxDistanceFromMarket(false),  // Limit max order price distance from market
	MaxDistancePct(6),  // Maximum distance from market price in %
	MaxTradesPerDay(0),
	MinimumSL(0),  // Minimum SL in ticks/pips, 0 means unlimited
	MaximumSL(0),  // Maximum SL in ticks/pips, 0 means unlimited
	MinimumPT(0),  // Minimum PT in ticks/pips, 0 means unlimited
	MaximumPT(0),  // Maximum PT in ticks/pips, 0 means unlimited	
	UseInitialStopLoss(false),  // Sets StopLoss immediately after the order gets filled. Otherwise SL is set on next bar.

	// Money Management - Fixed size
	mmLots(1.0),
    double mmMultiplier(1.0),
	InitialCapital(10000);

vars:
	// Internal variables
	LongEntrySignal(false),
	ShortEntrySignal(false),
	LongExitSignal(false),
	ShortExitSignal(false),
	NumberOfShares(0),
	tickSize(MinMove/PriceScale),
	OpenOrdersAllowed(true),
	IntPriceLevel(0),IntLongSL(0),IntShortSL(0),IntPT(0),
	IntLongTS(0),IntShortTS(0),
	IntLongBE(0),IntShortBE(0),
	LongSLPlaced(false),ShortSLPlaced(false),
   OrderSize(0),
   RemainingSize(0),
   ATMExitPrice(0);

	Array: bool cond[100](false);
   


// =================================================================
// TRADING OPTIONS LOGIC
// =================================================================
OpenOrdersAllowed = true;

// Dont trade on weekends
if DontTradeOnWeekends then begin
	if DayOfWeek(Date) = 5 then begin
		if FridayCloseTime <> 0000 and Time >= FridayCloseTime then begin
			OpenOrdersAllowed = False;
		end;	
	end
	else if DayOfWeek(Date) = 6 then begin
		OpenOrdersAllowed = False;
	end
	else if DayOfWeek(Date) = 0 and Time < SundayOpenTime then begin
		OpenOrdersAllowed = False;
	end; 
end;

// Exit on close (end of day)
if(ExitAtEndOfDay) then begin
	if DayExitTime <> 0000 and Time >= DayExitTime then begin
		if (MarketPosition > 0) then Sell("ExitEndOfDayL") This Bar On Close;
		if (MarketPosition < 0) then BuyToCover("ExitEndOfDayS") This Bar On Close;
		OpenOrdersAllowed = False;
	end
	else SetExitOnClose;
end;

// Exit on Friday
if ExitOnFriday then begin
	if DayOfWeek(Date) = 5 then begin
		if FridayExitTime <> 0000 and Time >= FridayExitTime then begin
			if (MarketPosition > 0) then Sell("ExitFridayL") This Bar On Close;
			if (MarketPosition < 0) then BuyToCover("ExitFridayS") This Bar On Close;
			OpenOrdersAllowed = False;
		end
		else SetExitOnClose;
	end
	else if DayOfWeek(Date) = 6 then begin
		OpenOrdersAllowed = False;
	end; 
end;

// Limit time range
if(OpenOrdersAllowed = True and LimitSignalsTimeRange = True and ((SignalTimeRangeFrom < SignalTimeRangeTo and (Time < SignalTimeRangeFrom or Time >= SignalTimeRangeTo)) or 
									   (SignalTimeRangeFrom >= SignalTimeRangeTo and (Time < SignalTimeRangeFrom and Time >= SignalTimeRangeTo)))
) then OpenOrdersAllowed = False;

// Max trades per day
if(OpenOrdersAllowed = True and MaxTradesPerDay <> 0 and EntriesToday(Date) >= MaxTradesPerDay) then
	OpenOrdersAllowed = False;    
    

	
// =================================================================
// TRADING RULES LOGIC
// =================================================================
               
//------------------------------------------------------------------
// Rule: Trading signals
//------------------------------------------------------------------
Value1= SQ_MACD(Close, MACDMainFast1, MACDMainSlow1, MACDMainSmooth1, 0)[2];
Value2= SQ_MACD(Close, MACDMainFast1, MACDMainSlow1, MACDMainSmooth1, 1)[2];
Value3= Open[1];
Value4= SQ_LinearRegression(Close, LinRegBarOpnAftOpnPrd1)[1];
Value5= Open[0];
LongEntrySignal = ((Value1<Value2) and (Value3 < Value4 and Value5 > Value4));


Value1= SQ_MACD(Close, MACDMainFast1, MACDMainSlow1, MACDMainSmooth1, 0)[2];
Value2= SQ_MACD(Close, MACDMainFast1, MACDMainSlow1, MACDMainSmooth1, 1)[2];
Value3= Open[1];
Value4= SQ_LinearRegression(Close, LinRegBarOpnAftOpnPrd1)[1];
Value5= Open[0];
ShortEntrySignal = ((Value1>Value2) and (Value3 > Value4 and Value5 < Value4));


LongExitSignal = false;


ShortExitSignal = false;




                
//------------------------------------------------------------------
// Rule: Long entry
//------------------------------------------------------------------
if LongEntrySignal

then begin
	// Action #1
	if(OpenOrdersAllowed) then begin        
		IntPriceLevel = Round2Fraction((Low[1] + (PriceEntryMult1 * (SQ_BollingerBands(Close, BBRangePeriod1, 2.6, 0)[1]-SQ_BollingerBands(Close, BBRangePeriod1, 2.6, 1)[1]))));

		If not LimitMaxDistanceFromMarket or Round(absvalue(IntPriceLevel - CurrentAsk) / CurrentAsk * 100, 2) <= MaxDistancePct Then begin
			NumberOfShares = mmLots * mmMultiplier;
			If NumberOfShares > 0 Then begin
				if(MarketPosition = 0) then  begin
					Buy("LongLimit") NumberOfShares shares next bar at IntPriceLevel limit;

					If UseInitialStopLoss Then begin
                  IntLongSL = SQ_ConvertToPips(Absvalue( - StopLoss1/100 * EntryPrice));
                  If MinimumSL > 0 and IntLongSL < MinimumSL Then IntLongSL = MinimumSL;
                  If MaximumSL > 0 and IntLongSL > MaximumSL Then IntLongSL = MaximumSL;

                  If IntLongSL > 0 Then begin
                     SetStopContract;
                     SetStopLoss((MinMove / PriceScale) * BigPointValue * IntLongSL);
                  end;
                  IntPT = SQ_ConvertToPips(Absvalue( + ProfitTarget1/100 * EntryPrice));
                  If MinimumPT > 0 and IntPT < MinimumPT Then IntPT = MinimumPT;
                  If MaximumPT > 0 and IntPT > MaximumPT Then IntPT = MaximumPT;

                  If IntPT > 0 Then begin
                     SetStopContract;
                     SetProfitTarget((MinMove / PriceScale) * BigPointValue * IntPT);
                  end;
					end;
				end;
			end;
		end;
	end;
end;

//------------------------
// Orders Exits (SL, PT, Trailing) for Rule: Long entry 
//------------------------
if(MarketPosition > 0) then begin

	LongSLPlaced = false;

	If BarsSinceEntry(0) = 0 then begin
		IntLongSL = 0;
		IntLongTS = 0;
		IntLongBE = 0;
	end;

	// StopLoss
	IntLongSL = EntryPrice - StopLoss1/100 * EntryPrice;
	IntLongSL = SQ_CorrectMinMaxSLPT(IntLongSL, MinimumSL, MaximumSL, true);
	If IntLongSL <> 0 Then begin
		Sell("LongSL") next bar at IntLongSL stop;
		LongSLPlaced = true;
	end Else IntLongSL = 0;

	// ProfitTarget init
	IntPT = EntryPrice + ProfitTarget1/100 * EntryPrice;
	IntPT = SQ_CorrectMinMaxSLPT(IntPT, MinimumPT, MaximumPT, false);
	If IntPT < 0 Then IntPT = 0;

	// Move SL to BE
	IntPriceLevel = MoveSL2BE1 * tickSize;
	If IntPriceLevel > 0 and (Entryprice <= Round2Fraction(Close - IntPriceLevel)) and (IntLongBE = 0 or IntLongBE < Entryprice + SL2BEAddPipsCoef1 * SQ_ATR(149)[1]) then begin
		IntLongBE = Entryprice + SL2BEAddPipsCoef1 * SQ_ATR(149)[1];
	end;
	If IntLongBE > 0 and IntLongBE > IntLongSL then begin
		Sell("LongSL2BE") next bar at IntLongBE stop;
		LongSLPlaced = true;
	end;		
         
	// Trailing Stop
	IntPriceLevel = TrailingStop1 * tickSize;
	If IntPriceLevel > 0 and Close - EntryPrice >= Round2Fraction(TrailingActivation1 * tickSize) and (IntLongTS = 0 or Round2Fraction(Close - IntPriceLevel) > IntLongTS) and Round2Fraction(Close - IntPriceLevel) < CurrentBid then begin
		IntLongTS = Round2Fraction(Close - IntPriceLevel); // remember also trailing stop
	end;
	If IntLongTS > 0 and IntLongTS > IntLongSL then begin
		Sell("LongTrailingStop") next bar at IntLongTS stop;
		LongSLPlaced = true;
	end;		
	
	// ExitAfterBars
	if (ExitAfterBars1 > 0 and BarsSinceEntry(0) >= ExitAfterBars1) then
		Sell("LongExitAfterXBars") next bar at market;
		
	If IntPT <> 0 then begin 
		Sell("LongPT") next bar at IntPT limit;
	end;
		
	if LongSLPlaced = false and IntLongSL > 0 then begin
		// no SL activated this bar, use default one - handling if there is no SL, only Trailing stop or Move2BE
		Sell("LongSLD") next bar at IntLongSL stop;
	end;	
end;

                
//------------------------------------------------------------------
// Rule: Short entry
//------------------------------------------------------------------
if (ShortEntrySignal and (LongEntrySignal = false))

then begin
	// Action #1
	if(OpenOrdersAllowed) then begin        
		IntPriceLevel = Round2Fraction((High[1] - (PriceEntryMult1 * (SQ_BollingerBands(Close, BBRangePeriod1, 2.6, 0)[1]-SQ_BollingerBands(Close, BBRangePeriod1, 2.6, 1)[1]))));

		If not LimitMaxDistanceFromMarket or Round(absvalue(IntPriceLevel - CurrentBid) / CurrentBid * 100, 2) <= MaxDistancePct Then begin
			NumberOfShares = mmLots * mmMultiplier;
			If NumberOfShares > 0 Then begin
				if(MarketPosition = 0) then  begin
					SellShort("ShortLimit") NumberOfShares shares next bar at IntPriceLevel limit;

					If UseInitialStopLoss Then begin
                  IntShortSL = SQ_ConvertToPips(Absvalue( + StopLoss1/100 * EntryPrice));
                  If MinimumSL > 0 and IntShortSL < MinimumSL Then IntShortSL = MinimumSL;
                  If MaximumSL > 0 and IntShortSL > MaximumSL Then IntShortSL = MaximumSL;

                  If IntShortSL > 0 Then begin
                     SetStopContract;
                     SetStopLoss((MinMove / PriceScale) * BigPointValue * IntShortSL);
                  end;
                  IntPT = SQ_ConvertToPips(Absvalue( - ProfitTarget1/100 * EntryPrice));
                  If MinimumPT > 0 and IntPT < MinimumPT Then IntPT = MinimumPT;
                  If MaximumPT > 0 and IntPT > MaximumPT Then IntPT = MaximumPT;

                  If IntPT > 0 Then begin
                     SetStopContract;
                     SetProfitTarget((MinMove / PriceScale) * BigPointValue * IntPT);
                  end;
					end;
				end;
			end;
		end;
	end;
end;

//------------------------
// Orders Exits (SL, PT, Trailing) for Rule: Short entry 
//------------------------
if(MarketPosition < 0) then begin

	ShortSLPlaced = false;

	If BarsSinceEntry(0) = 0 then begin
		IntShortSL = 0;
		IntShortTS = 0;
		IntShortBE = 0;
	end;

	// StopLoss
	IntShortSL = EntryPrice + StopLoss1/100 * EntryPrice;
	IntShortSL = SQ_CorrectMinMaxSLPT(IntShortSL, MinimumSL, MaximumSL, true);
	If IntShortSL <> 0 Then begin
		BuyToCover("ShortSL") next bar at IntShortSL stop;
		ShortSLPlaced = true;
	end Else IntShortSL = 0;

	// ProfitTarget init
	IntPT = EntryPrice - ProfitTarget1/100 * EntryPrice;
	IntPT = SQ_CorrectMinMaxSLPT(IntPT, MinimumPT, MaximumPT, false);
	If IntPT < 0 Then IntPT = 0;

	// Move SL to BE
	IntPriceLevel = MoveSL2BE1 * tickSize;
	If IntPriceLevel > 0 and (Entryprice >= Round2Fraction(Close + IntPriceLevel)) and (IntShortBE = 0 or IntShortBE > Entryprice - SL2BEAddPipsCoef1 * SQ_ATR(149)[1]) then begin
		IntShortBE = Entryprice - SL2BEAddPipsCoef1 * SQ_ATR(149)[1];
	end;
	If IntShortBE > 0 and (IntShortBE < IntShortSL or IntShortSL = 0) then begin
		BuyToCover("ShortSL2BE") next bar at IntShortBE stop;
		ShortSLPlaced = true;
	end;		
         
	// Trailing Stop
	IntPriceLevel = TrailingStop1 * tickSize;
	If IntPriceLevel > 0 and EntryPrice - Close >= Round2Fraction(TrailingActivation1 * tickSize) and (IntShortTS = 0 or Round2Fraction(Close + IntPriceLevel) < IntShortTS) and Round2Fraction(Close + IntPriceLevel) > CurrentAsk then begin
		IntShortTS = Round2Fraction(Close + IntPriceLevel);
	end;   
	If IntShortTS > 0 and (IntShortTS < IntShortSL or IntShortSL = 0)  then begin
		BuyToCover("ShortTrailingStop") next bar at IntShortTS stop;
		ShortSLPlaced = true;
	end;		
	
	// ExitAfterBars
	if (ExitAfterBars1 > 0 and BarsSinceEntry(0) >= ExitAfterBars1) then
		BuyToCover("ShortExitAfterXBars") next bar at market;
		
	If IntPT <> 0 then begin 
		BuyToCover("ShortPT") next bar at IntPT limit;
	end;
		
	if ShortSLPlaced = false and IntShortSL > 0 then begin
		// no SL activated this bar, use default one - handling if there is no SL, only Trailing stop or Move2BE
		BuyToCover("ShortSLD") next bar at IntShortSL stop;
	end;	
end;

                
//------------------------------------------------------------------
// Rule: Long exit
//------------------------------------------------------------------
if ((LongExitSignal and (LongEntrySignal = false)) and (MarketPosition > 0))

then begin
	// Action #1
Sell("ClosePositionLong") next bar at market;
end;


                
//------------------------------------------------------------------
// Rule: Short exit
//------------------------------------------------------------------
if ((ShortExitSignal and (ShortEntrySignal = false)) and (MarketPosition < 0))

then begin
	// Action #1
BuyToCover("ClosePositionShort") next bar at market;
end;


                



